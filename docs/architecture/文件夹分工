这套结构是典型的 **领域驱动设计（DDD）** 简化版架构。它不仅仅是为了好看，更核心的目的是为了**解耦**：把“业务逻辑”和“技术实现”分开，确保代码在后期扩展时不会乱成一锅粥。

---

## 一、 核心四层架构 (每个业务模块内部)

你每个模块（如 `auth`, `document` 等）下都有四个子文件夹，它们的职责分工非常明确：

| 文件夹 | 角色 | 解释 |
| --- | --- | --- |
| **api** | **门面层 (Adapter)** | 负责对外提供接口。包含 `Controller`、入参校验 `DTO`。它只负责接收请求和返回数据，不写业务逻辑。 |
| **application** | **应用层 (Orchestrator)** | **业务编排员**。负责组合不同的领域服务来完成一个具体的用例（如“处理审批并发送通知”）。 |
| **domain** | **领域层 (Heart)** | **项目的核心**。存放实体（Entity）、聚合根、领域服务和 **Repository 接口**。业务规则应该写在这里。 |
| **infrastructure** | **基础设施层 (Tooling)** | **具体实现类**。比如 MyBatis 的 `Mapper` 实现、第三方支付接口调用、Redis 缓存实现等。 |

---

## 二、 业务模块功能划分

这些文件夹代表了系统的不同功能边界：

* **auth (权限与用户)**：处理登录、注册、JWT 校验、RBAC 权限（角色/资源）控制。
* **folder (文件夹/项目)**：管理系统的目录结构，比如创建项目空间、文件夹的层级关系维护。
* **document (文件与版本)**：核心业务。处理文件上传、下载、物理存储路径、版本更迭（V1/V2）记录。
* **workflow (审批流程)**：处理文件的审核状态流转。例如：提交 -> 部门领导审批 -> 归档。
* **notify (消息通知)**：站内信、邮件提醒、钉钉/机器人推送等异步通知逻辑。
* **audit (审计模块)**：记录“谁在什么时候对哪个文件做了什么”，用于合规检查和日志溯源。

---

## 三、 Common 通用层 (公共脚手架)

这一层不含具体的业务逻辑，是所有模块都要用到的“工具箱”：

* **constant**：全局常量（如：文件状态枚举、系统默认值）。
* **exception**：自定义异常类（如：`BusinessException`）和全局异常处理器。
* **result**：统一封装返回对象（如：`Result<T>`），确保前端收到的 JSON 格式永远一致。
* **util**：各种工具类（日期处理、MD5 加密、文件切片工具等）。
* **config**：全局配置类（Swagger/Knife4j 配置、MyBatis-Plus 分页插件、线程池配置等）。

---

## 四、 根目录与资源文件

* **Dockerfile**：项目的容器化“说明书”，用于一键部署到服务器。
* **resources/mapper**：存放 SQL 语句的 XML 文件，与 `infrastructure` 层中的接口对应。
* **application-dev/prod.yml**：**区分环境**。开发环境用本地数据库，生产环境用云端数据库。

---

### 💡 避坑小建议

在 DDD 结构中，初学者最容易犯的错误是**把所有逻辑都写在 `application` 层**。

* **记住**：如果一个逻辑是“某个对象自己就能决定的”（比如：判断订单是否可以取消），请写在 `domain`；如果这个逻辑需要“调动好几个模块协同”（比如：取消订单后退款并通知用户），请写在 `application`。

**你现在是准备先从 `common` 层的通用返回对象开始写，还是先定义 `auth` 模块的数据库表结构？**